
&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	Токен = "<Ещё не получен>";
	
	Если Не ЗначениеЗаполнено(Сервер) Тогда
		Сервер = "ismp.crpt.ru";
	КонецЕсли;
		
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	
	CAPICOM_CURRENT_USER_STORE = 2; //2 - искать сертификат в ветке "Личное" хранилища
	CAPICOM_MY_STORE = "My"; // указываем, что ветку "Личное" берем из хранилища текущего пользователя
	CAPICOM_STORE_OPEN_READ_ONLY = 0; // открыть хранилище только на чтение
	
	oStore = Новый COMОбъект("CAdESCOM.Store"); // Объект описывает хранилище сертификатов.	
	
	// Открыть хранилище сертификатов.
	oStore.Open(CAPICOM_CURRENT_USER_STORE, CAPICOM_MY_STORE, CAPICOM_STORE_OPEN_READ_ONLY);
	Для каждого Элемент из oStore.Certificates Цикл		
		ПолноеИмяСубъекта = Элемент.SubjectName;
		
		НоваяСтрока = ТаблицаСертификатов.Добавить();
		НоваяСтрока.ПолноеИмяСубъекта = ПолноеИмяСубъекта;
		НоваяСтрока.Представление = ПредставлениеСертификата(ПолноеИмяСубъекта, Элемент.ValidFromDate, Элемент.ValidToDate);
		НоваяСтрока.Отпечаток = Элемент.Thumbprint;
	КонецЦикла;	
	oStore.Close(); // Закрыть хранилище сертификатов и освободить объект 61
	
	Для каждого СтрокаТаблицы из ТаблицаСертификатов Цикл
		Элементы.Сертификат.СписокВыбора.Добавить(СтрокаТаблицы.Представление);	
	КонецЦикла;
	
КонецПроцедуры

&НаКлиенте
Процедура СертификатПриИзменении(Элемент)
	
	Если ЗначениеЗаполнено(Сертификат) Тогда
		ПараметрыОтбора = Новый Структура;
		ПараметрыОтбора.Вставить("Представление", Сертификат);
		НайденныеСтроки = ТаблицаСертификатов.НайтиСтроки(ПараметрыОтбора);
		Отпечаток = НайденныеСтроки[0].Отпечаток;
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ПолучиьТокен(Команда)
	
	Соединение = Новый HTTPСоединение(Сервер, 443,,,,, Новый ЗащищенноеСоединениеOpenSSL);
	
	// 1. Запрос авторизацией: возвращает УИД и текст, который надо подписать.
	Запрос = Новый HTTPЗапрос(БазовыйАдресСтенда + "/auth/cert/key");
	Ответ = Соединение.ВызватьHTTPМетод("GET", Запрос);
	ОтветЗапросаАвторизации = Ответ.ПолучитьТелоКакСтроку("UTF-8");
	ОтветЗапросаАвторизации = СтруктураИзJSON(ОтветЗапросаАвторизации);
	
	// 2. Текст, полученный из запроса вторизации, надо зашифровать и подписать.
	ТекстДляПодписывания = ОтветЗапросаАвторизации.data;
	ТекстДляПодписывания = ЗашифроватьBase64(ТекстДляПодписывания, КодировкаТекста.UTF8);
	ПодписанныйТекст = ПодписатьТекст(ТекстДляПодписывания, Отпечаток, Ложь);
	
	// Структура данных для запроса токена.
	Данные = Новый Структура;
	Данные.Вставить("uuid", ОтветЗапросаАвторизации.uuid);
	Данные.Вставить("data", ПодписанныйТекст);
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Данные); // превращаем в JSON
	Данные = ЗаписьJSON.Закрыть();
	
	Заголовки = Новый Соответствие; // заголовки для запроса токена
	Заголовки.Вставить("Content-Type", "application/json; charset=UTF-8");
	Заголовки.Вставить("Accept", "application/json");
	
	// 3. Запрос получения аутентификационного токена: возвращает данные с токеном.
	Запрос = Новый HTTPЗапрос(БазовыйАдресСтенда + "/auth/cert/", Заголовки);
	Запрос.УстановитьТелоИзСтроки(Данные,
								  КодировкаТекста.UTF8,
								  ИспользованиеByteOrderMark.НеИспользовать);
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	Ответ = СтруктураИзJSON(Ответ.ПолучитьТелоКакСтроку());
	
	Токен = Ответ.token;
	
КонецПроцедуры

&НаКлиенте
Функция СтруктураИзJSON(СтрокаJSON)
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	Результат = ПрочитатьJSON(ЧтениеJSON); // превращаем в структуру
	ЧтениеJSON.Закрыть();
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Процедура ПеречитатьДокументы(Команда)
		
	Соединение = Новый HTTPСоединение(Сервер, 443,,,,, Новый ЗащищенноеСоединениеOpenSSL);
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Authorization", "Bearer " + Токен);
	
	Парметры = "order=DESC&orderColumn=receivedAt";
	
	// Запрос получения списка загруженных документов. Пункт 2.1.7 описания API.
	Запрос = Новый HTTPЗапрос(БазовыйАдресСтенда + "/facade/doc/listV2?" + Парметры, Заголовки);
	Ответ = Соединение.ВызватьHTTPМетод("GET", Запрос);
	Ответ = СтруктураИзJSON(Ответ.ПолучитьТелоКакСтроку());
	
	СтруктураСтрокиРезультата = Новый Структура;
	СтруктураСтрокиРезультата.Вставить("number",       "Номер");
	СтруктураСтрокиРезультата.Вставить("docDate",      "Дата");
	СтруктураСтрокиРезультата.Вставить("receivedAt",   "Получен");
	СтруктураСтрокиРезультата.Вставить("externalId",   "ВнешнийID");
	СтруктураСтрокиРезультата.Вставить("senderName",   "Отправитель");
	СтруктураСтрокиРезультата.Вставить("receiverName", "Получатель");
	
	ТаблицаДокументов.Очистить();	
	Для каждого СтрокаРезультатов из Ответ.results Цикл
		НоваяСтрока = ТаблицаДокументов.Добавить();
		
		Для каждого КлючЗначение из СтруктураСтрокиРезультата Цикл
			ИмяПоля = КлючЗначение.Ключ;
			ИмяПоляНаФорме = КлючЗначение.Значение;
			Если СтрокаРезультатов.Свойство(ИмяПоля) Тогда
				НоваяСтрока[ИмяПоляНаФорме] = СтрокаРезультатов[ИмяПоля];
			КонецЕсли;
		КонецЦикла;		
	КонецЦикла;
	
КонецПроцедуры

// sThumbprint - отпечаток сертификата, используемого для подписи; строка,
// представляющая отпечаток в шестнадцатеричном виде, например: 195934d72dcdf69149901d6632aca4562d8806d8.
// ТекстДляПодписи должен быть в Base64
// bDetached - Истина/Ложь - откреплённая(для подписаниядокументов)/прикреплённая(для получения токена авторизации) подпись
&НаКлиенте
Функция ПодписатьТекст(Сообщение, sThumbprint, bDetached)
	
	CADESCOM_BASE64_TO_BINARY = 1; // входные данные пришли в Base64
	CADESCOM_CADES_TYPE = 1; // тип усовершенствованной подписи
	CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME = 0; // атрибут штампа времени подписи
	
	// Объект, задающий параметры создания и содержащий информацию об усовершенствованной подписи.
	oSigner = Новый COMОбъект("CAdESCOM.CPSigner");
	oSigner.Certificate = ПолучитьСертификатПоОтпечатку(sThumbprint);
	
	oSigningTimeAttr = Новый COMОбъект("CAdESCOM.CPAttribute");
	oSigningTimeAttr.Name = CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME;
	oSigningTimeAttr.Value = ТекущаяДата();
	oSigner.AuthenticatedAttributes2.Add(oSigningTimeAttr);
	
	// Объект CadesSignedData предоставляет свойства и методы для работы с усовершенствованной подписью.
	oSignedData = Новый COMОбъект("CAdESCOM.CadesSignedData");
	oSignedData.ContentEncoding = CADESCOM_BASE64_TO_BINARY;
	oSignedData.Content = Сообщение;
	EncodingType = 0;
	
	// Метод добавляет к сообщению усовершенствованную подпись.
	sSignedMessage = oSignedData.SignCades(oSigner, CADESCOM_CADES_TYPE, bDetached, EncodingType);
	
	Возврат sSignedMessage; // подписанное сообщение в формате Base64
	
КонецФункции

&НаКлиенте
Функция ПолучитьСертификатПоОтпечатку(Отпечаток)
	
	Результат = Неопределено; // Найденный сертификат (Com-объект)
	
	CAPICOM_CURRENT_USER_STORE = 2; //2 - искать сертификат в ветке "Личное" хранилища.
	CAPICOM_MY_STORE = "My"; // указываем, что ветку "Личное" берем из хранилища текущего пользователя
	CAPICOM_STORE_OPEN_READ_ONLY = 0; // Открыть хранилище только на чтение
	
	oStore = Новый COMОбъект("CAdESCOM.Store"); // Объект описывает хранилище сертификатов 246
	
	// Открыть хранилище сертификатов.
	oStore.Open(CAPICOM_CURRENT_USER_STORE, CAPICOM_MY_STORE, CAPICOM_STORE_OPEN_READ_ONLY);
	
	// Вариант 1: поиск сертификата по отпечатку
	CAPICOM_CERTIFICATE_FIND_SHA1_HASH = 0;
	Certificates = oStore.Certificates.Find(CAPICOM_CERTIFICATE_FIND_SHA1_HASH, Отпечаток);
	Результат = Certificates.Item(1);
	
	// Вариант 2: обходом по коллекции и сравнение с отпечатком
	//Для Каждого ТекСертификат Из oStore.Certificates Цикл
	//	ТекОтпечаток = ТекСертификат.Thumbprint; // возвращается отпечаток в шестнадцатеричном виде
	//	Если ВРЕГ(ТекОтпечаток) = ВРЕГ(ОтпечатокСтр) Тогда
	//		Результат = ТекСертификат;
	//		Прервать;
	//	КонецЕсли;
	//КонецЦикла;
	
	oStore.Close(); // Закрыть хранилище сертификатов и освободить объект 61
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ЗашифроватьBase64(Строка, Кодировка) Экспорт
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("txt");
	
	ЗаписьТекста = Новый ЗаписьТекста(ИмяВременногоФайла, Кодировка);
    ЗаписьТекста.Записать(Строка);
    ЗаписьТекста.Закрыть();
	
	Двоичные = Новый ДвоичныеДанные(ИмяВременногоФайла);
    Результат = Base64Строка(Двоичные);
	
	Если Лев(Результат, 4) = "77u/" Тогда
		Результат = Сред(Результат, 5);
	КонецЕсли; 
	Результат = СтрЗаменить(Результат, Символы.ПС, "");
	
	УдалитьФайлы(ИмяВременногоФайла);
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ПредставлениеСертификата(СтрокаПараметров, НачалоПериода, КонецПериода)
	
	// В большинстве случаев эта логика будет работать.
	// Но если в значениях атрибутов будут встречаться подстроки имен аттрибутов со знаком равно,
	// (например, "T=") то алгоритм будет ложно находить позиции аттрибутов и будут глюки.
	// Но, по-идее, в строках адресов не должно быть подстрок типа "Т=" и подобных.
	
	ФорматнаяСтрока = "ДФ='dd.MM.yyyy HH:mm'";
	ДатаС  = Формат(НачалоПериода, ФорматнаяСтрока);
	ДатаПо = Формат(КонецПериода,  ФорматнаяСтрока);
	
	ВсеАттрибуты = "CN,SN,G,O,T,STREET,L,S,C,ИНН,ОГРН,СНИЛС,E";
	мАттрибуты = СтрРазделить(ВсеАттрибуты, ",");
	Аттрибуты = Новый Структура;
	
	Для каждого Аттрибут из мАттрибуты Цикл
		
		ПозицияАттрибута = СтрНайти(СтрокаПараметров, Аттрибут + "=");
		Если ПозицияАттрибута = 0 Тогда
			Продолжить; // такого атрибута нет в строке параметров	
		КонецЕсли;
		
		// Установим начальную позицию значения атрибута
		ДлинаСтрокиАттрибута = СтрДлина(Аттрибут);
		НачальнаяПозицияЗначения = ПозицияАттрибута + ДлинаСтрокиАттрибута + 1;
		
		// Для установления конечной позиции значения будем искать в строке следующий (ближайший) аттрибут.
		
		// Ищем в строке параметров позицию ближайшего атрибута, следующего за текущим.
		ПозицияБлижайшегоАтрибута = 99999;
		Для каждого ДругойАтрибут из мАттрибуты Цикл
			Если ДругойАтрибут = Аттрибут Тогда
				Продолжить; // это не другой атрибут, а этот же самый
			КонецЕсли;
			
			ПозицияДругогоАттрибута = СтрНайти(СтрокаПараметров, ДругойАтрибут + "=",, ПозицияАттрибута + ДлинаСтрокиАттрибута);
			
			Если ПозицияДругогоАттрибута <> 0 Тогда // другой атрибут найден
				Если ПозицияДругогоАттрибута < ПозицияБлижайшегоАтрибута Тогда // очередной другой атрибут ближе прочих
					ПозицияБлижайшегоАтрибута = ПозицияДругогоАттрибута;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Если ПозицияБлижайшегоАтрибута = 99999 Тогда // текущий атрибут последний в строке параметров
			КонечнаяПозицияЗначения = СтрДлина(СтрокаПараметров); // конечная позиция это конец строки
		Иначе
			КонечнаяПозицияЗначения = ПозицияБлижайшегоАтрибута - 2;
		КонецЕсли;
		
		ДлинаЗначения = КонечнаяПозицияЗначения - НачальнаяПозицияЗначения;
		Значение = Сред(СтрокаПараметров, НачальнаяПозицияЗначения, ДлинаЗначения);
		
		// Если значение начинается и заканчивается кавычками, убираем их.
		Если Лев(Значение, 1) = """" и Прав(Значение, 1) = """" Тогда
			Значение = Сред(Значение, 2, СтрДлина(Значение) - 2);	
		КонецЕсли;
		Значение = СтрЗаменить(Значение, """""", """");
		
		Аттрибуты.Вставить(Аттрибут, Значение);
		
	КонецЦикла;
	
	Результат = "";
	Если Аттрибуты.Свойство("CN") Тогда
		Результат = Результат + Аттрибуты.CN;
	КонецЕсли;
	
	Возврат Результат + " (" + ДатаС + " - " + ДатаПо + ")";
	
КонецФункции

&НаКлиенте
Процедура ОтправитьДокумент(Команда)
	
	ТоварнаяГруппа = "lp";
	ТекстДокументаBase64 = ЗашифроватьBase64(ДокументДляОтравки, КодировкаТекста.UTF8);
	ПодписанныйТекст = ПодписатьТекст(ТекстДокументаBase64, Отпечаток, Истина); // третий параметр = ИСТИНА для документов
	
	ТелоЗапроса = Новый Структура;
	ТелоЗапроса.Вставить("document_format", "XML");
	ТелоЗапроса.Вставить("product_document", ТекстДокументаBase64);
	ТелоЗапроса.Вставить("type", "LP_SHIP_GOODS_XML");
	ТелоЗапроса.Вставить("signature", ПодписанныйТекст);
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);
	ТелоЗапроса = ЗаписьJSON.Закрыть();
	
	Соединение = Новый HTTPСоединение(Сервер, 443,,,,, Новый ЗащищенноеСоединениеOpenSSL);
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("content-type", "application/json");
	Заголовки.Вставить("Authorization", "Bearer " + Токен);
	
	Параметры = "pg=" + ТоварнаяГруппа;
	
	// Запрос 3.1 Единый метод создания документов
	Запрос = Новый HTTPЗапрос(БазовыйАдресСтенда + "/lk/documents/create?" + Параметры, Заголовки);
	Запрос.УстановитьТелоИзСтроки(ТелоЗапроса);
	Ответ = Соединение.ВызватьHTTPМетод("POST", Запрос);
	
КонецПроцедуры





