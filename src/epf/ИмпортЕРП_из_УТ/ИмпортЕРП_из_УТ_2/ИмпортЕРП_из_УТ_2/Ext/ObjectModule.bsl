// https://infostart.ru/1c/articles/827126/
Перем мИДСессии;
Перем мЧтениеJSON;
Перем Плагины; // структура
Перем КэшОбъектовПлагинов; //ТЗ
Перем ИмяСобытияЖР;
Перем мСчетчикПересозданияКлиентаРэббит;
Перем consumerId; 
Перем мКлиент; 
Перем ИмяОчереди; 
Перем мКоличествоПолученных;   
Перем мТегСообщения;
Перем мЛоггер;
Перем мИдВызова;

#Область ПодключениеОбработкиКБСП

Функция СведенияОВнешнейОбработке() Экспорт

	ПараметрыРегистрации = ДополнительныеОтчетыИОбработки.СведенияОВнешнейОбработке();

	ПараметрыРегистрации.Вставить("Вид",ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиДополнительнаяОбработка());
	ПараметрыРегистрации.Вставить("Версия","1.3");
	//ПараметрыРегистрации.Вставить("Назначение", Новый Массив);
	ПараметрыРегистрации.Вставить("Наименование","Импорт из 1С:УТ");
	ПараметрыРегистрации.Вставить("БезопасныйРежим", Ложь);
	ПараметрыРегистрации.Вставить("Информация","Импорт из 1С:УТ");
	ПараметрыРегистрации.Вставить("ВерсияБСП", "3.1.7.306"); // ОБЯЗАТЕЛЬНО!!! //(https://forum.infostart.ru/forum9/topic179193/)
	//ПараметрыРегистрации.Вставить("ОпределитьНастройкиФормы", Ложь);
	
	
	ТипКоманды = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыОткрытиеФормы();
	ДобавитьКоманду(ПараметрыРегистрации.Команды, "Открыть форму : Импорт из 1С:УТ","ЗагрузитьДанныеИз1СУТИнтерактивно",ТипКоманды, Ложь) ;
	
	ТипКоманды = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовСерверногоМетода();
	ДобавитьКоманду(ПараметрыРегистрации.Команды, "Выполнить импорт НСИ из 1С:УТ","ЗагрузитьНСИИз1СУТ",ТипКоманды, Ложь) ;
	
	ТипКоманды = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовСерверногоМетода();
	ДобавитьКоманду(ПараметрыРегистрации.Команды, "Выполнить импорт документов из 1С:УТ","ЗагрузитьДокументыИз1СУТ",ТипКоманды, Ложь) ;

	Возврат ПараметрыРегистрации;
	
КонецФункции

Процедура ДобавитьКоманду(ТаблицаКоманд, Представление, Идентификатор, Использование, ПоказыватьОповещение = Ложь, Модификатор = "")

	//ТаблицаКоманд.Колонки.Добавить("Представление", РеквизитыТабличнойЧасти.Представление.Тип);
	//ТаблицаКоманд.Колонки.Добавить("Идентификатор", РеквизитыТабличнойЧасти.Идентификатор.Тип);
	//ТаблицаКоманд.Колонки.Добавить("Использование", Новый ОписаниеТипов("Строка"));
	//ТаблицаКоманд.Колонки.Добавить("ПоказыватьОповещение", РеквизитыТабличнойЧасти.ПоказыватьОповещение.Тип);
	//ТаблицаКоманд.Колонки.Добавить("Модификатор", РеквизитыТабличнойЧасти.Модификатор.Тип);
	//ТаблицаКоманд.Колонки.Добавить("Скрыть",      РеквизитыТабличнойЧасти.Скрыть.Тип);
	//ТаблицаКоманд.Колонки.Добавить("ЗаменяемыеКоманды", РеквизитыТабличнойЧасти.ЗаменяемыеКоманды.Тип);
	
//           ** Использование - Строка - тип команды:
//               "ВызовКлиентскогоМетода",
//               "ВызовСерверногоМетода",
//               "ЗаполнениеФормы",
//               "ОткрытиеФормы" или
//               "СценарийВБезопасномРежиме".
//               Для получения типов команд рекомендуется использовать функции
//               ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКоманды<ИмяТипа>.
//               В комментариях к этим функциям также даны шаблоны процедур-обработчиков команд.

	НоваяКоманда = ТаблицаКоманд.Добавить() ;
	НоваяКоманда.Представление = Представление ;
	НоваяКоманда.Идентификатор = Идентификатор ;
	НоваяКоманда.Использование = Использование ;
	НоваяКоманда.ПоказыватьОповещение = ПоказыватьОповещение ;
	НоваяКоманда.Модификатор = Модификатор ;
КонецПроцедуры

// Интерфейс для запуска логики обработки.
Процедура ВыполнитьКоманду(ИмяКоманды, ПараметрыВыполнения) Экспорт
	
	Если ИмяКоманды = "ЗагрузитьДокументыИз1СУТ" Тогда
		ВыполнитьИмпортДокументов();
	ИначеЕсли ИмяКоманды = "ЗагрузитьНСИИз1СУТ" Тогда
		ВыполнитьИмпортНСИ();
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти 	



// Описание_метода
//
// Параметры:
//	ИдВызова 	- спр ИндексЛога - 
//
Процедура ВыполнитьИмпортДокументов(Знач ИдВызова = Неопределено) Экспорт
	
	мИДСессии = Строка(Новый УникальныйИдентификатор);
	
	мИдВызова = ИдВызова;
	мЛоггер = мис_ЛоггерСервер.getLogger(ИдВызова, "Импорт документов из УТ");
	
	Очередь = "to-erp-from-ut-doc";

	мЛоггер.инфо("Запуск. Имя очереди: %1", Очередь);

	Плагины();

	Если мЧтениеJSON = Неопределено Тогда
		мЧтениеJSON = Новый ЧтениеJSON;
	КонецЕсли;
	
	ЗагрузитьДанныеИзОчереди(Очередь);
	
	мЛоггер.инфо("Завершение");
		
КонецПроцедуры

Процедура ВыполнитьИмпортНСИ(Знач ИдВызова = Неопределено) Экспорт
	
	мИДСессии = Строка(Новый УникальныйИдентификатор);
	
	мЛоггер = мис_ЛоггерСервер.getLogger(ИдВызова, "Импорт НСИ из УТ");
	
	Очередь = "to-erp-from-ut-static";
	
	мЛоггер.инфо("Запуск. Имя очереди: %1", Очередь);
	
	Плагины();

	Если мЧтениеJSON = Неопределено Тогда
		мЧтениеJSON = Новый ЧтениеJSON;
	КонецЕсли;
	
	ЗагрузитьДанныеИзОчереди(Очередь);
	
	мЛоггер.инфо("Завершение");
		
КонецПроцедуры



#Область Плагины

// Собирает плагины из спр Доп. обработки в ТЗ
//
// Параметры:
//	Параметр1 	- Тип1 - 
//
// Возвращаемое значение:
//	Тип: Тип_значения
//
Функция НайтиПлагиныВДопОбработках()
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	спр.Ссылка КАК Ссылка,
		|	спр.ИмяОбъекта КАК ИмяОбъекта
		|ИЗ
		|	Справочник.ДополнительныеОтчетыИОбработки КАК спр
		|ГДЕ
		|	спр.ИмяОбъекта ПОДОБНО ""Плагин_RabbitMQ_импорт_из_УТ%""
		|	И спр.ПометкаУдаления = ЛОЖЬ
		|	И НЕ спр.Публикация = &ПубликацияОтключена";
		
		
	Запрос.УстановитьПараметр("ПубликацияОтключена", Перечисления.ВариантыПубликацииДополнительныхОтчетовИОбработок.Отключена);
	РезультатЗапроса = Запрос.Выполнить();
	
	Возврат РезультатЗапроса.Выгрузить();
	
КонецФункции

// Подключает плагины - обработки, формирующие json-тексты из объектов базы данных
//
// Параметры:
//	Параметр1 	- Тип1 - 
//
Процедура Плагины() Экспорт
	
	Если ТипЗнч(Плагины) <> Тип("Структура") Тогда
		Плагины = Новый Структура;
	Иначе 
		Плагины.Очистить();
	КонецЕсли;
	
	
	// универсальный код подключения плагина
	
	ТЗ = НайтиПлагиныВДопОбработках();
	Для каждого стрк Из ТЗ Цикл

		ИмяОбработки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(стрк.ИмяОбъекта, ".");//разделим на имя расширени
		
		массивСлов = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяОбработки[0], "_");
		
		//Плагин_RabbitMQ_импорт_из_ЕРП_Справочник_Номенклатура.epf	
		//ключ - тип объекта МД (напр. Справочник_Номенклатура), значение - ссылка в Доп обработках
		Ключ = массивСлов[5] + "_" + массивСлов[6];

		Плагины.Вставить(Ключ, стрк.Ссылка);
		
	КонецЦикла;	
	
	
	// теперь создание объектов обработок
	
	КэшОбъектовПлагинов = Новый ТаблицаЗначений;
	КэшОбъектовПлагинов.Колонки.Добавить("ТипОбъекта");//строка в формате "Справочник_Номенклатура"
	КэшОбъектовПлагинов.Колонки.Добавить("ПлагинСсылка");//спр ссылка Доп. обработки
	КэшОбъектовПлагинов.Колонки.Добавить("ОбъектПлагина");//объект обработки
	//индексы
	КэшОбъектовПлагинов.Индексы.Добавить("ТипОбъекта");
	КэшОбъектовПлагинов.Индексы.Добавить("ПлагинСсылка");
	
	Для каждого стрк Из Плагины Цикл
		НовСтр = КэшОбъектовПлагинов.Добавить();
		НовСтр.ТипОбъекта 		= стрк.Ключ;
		НовСтр.ПлагинСсылка 	= стрк.Значение;
		НовСтр.ОбъектПлагина 	= ДополнительныеОтчетыИОбработки.ОбъектВнешнейОбработки(стрк.Значение);
	КонецЦикла;
	
		
КонецПроцедуры

// Ищет плагин для указанного типа объекта в кэше - ТЗ "КэшОбъектовПлагинов"
// Параметры:
//	ТипОбъекта 	- строка - это не ТипЗнч()! а вот так: Объект.Метаданные().ПолноеИмя();
//	Плагин - объект обработки - возвращаемый параметр
//
// Возвращаемое значение:
//	Тип: Булево. Истина в случае успеха
//
Функция НайтиПлагин(Знач ТипОбъекта, Плагин = Неопределено)
	
	ТипОбъекта = СтрЗаменить(ТипОбъекта, ".", "_");
	
	Рез = КэшОбъектовПлагинов.Найти(ТипОбъекта, "ТипОбъекта");
	Если НЕ Рез = Неопределено Тогда
		Плагин = Рез.ОбъектПлагина;
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
	
КонецФункции


#КонецОбласти 	



// Описание_метода
//
// Параметры:
//	Параметр1 	- Тип1 - 
//
// Возвращаемое значение:
//	Тип: Тип_значения
//
Функция Подключиться()
	
	//https://github.com/BITERP/PinkRabbitMQ
    queue = ИмяОчереди; //- Строка - Очередь из которой будем читать сообщения.
    consumerId = ""; //- Строка - [НЕ РЕАЛИЗОВАНО] имя потребителя. Если не задан, то имя потребителя сгенерирует сервер и вернет из метода
    noConfirm = Ложь;//- Булево - не ждать подтверждения обработки. Сообщения будут удалены из очереди сразу после отправки на клиента.
    exclusive = Ложь;// - Булево - монопольно захватить очередь
    selectSize = 100; //- Число - количество единовременно считываемых сообщений из очереди в кеш компоненты. Оптимизационный параметр, который влияет на скорость забора сообщений. Рекомендуемый диапазон 100-1000. Нежелательно устанавливать слишком высокие значения, т.к. чтение большого числа накопленных сообщений в очереди может спровоцировать нехватку памяти на клиенте 1С и падение компоненты без вызова исключения.
    arguments = "";// - Строка - [НЕОБЯЗАТЕЛЬНЫЙ] произвольные свойства в формате Json-объект. Пример: {"x-stream-offset": "first"}.
	СтрокаПодключенияДляЖР = 		"queue = "+queue+Символы.ПС+
    	"consumerId = "+consumerId+Символы.ПС+
		"noConfirm = "+noConfirm+Символы.ПС+
		"exclusive = "+exclusive+Символы.ПС+
		"selectSize = "+selectSize+Символы.ПС+
		"arguments = "+arguments+Символы.ПС;
	
	Попытка
		consumerId = мКлиент.BasicConsume(queue, consumerId, noConfirm, exclusive, selectSize, arguments);
		ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Предупреждение,,,
		"Потребитель подключен под именем: "+Строка(consumerId)+". Сессия ИД "+мИДСессии
		+Символы.ПС+СтрокаПодключенияДляЖР);
		
	Исключение
		т = мКлиент.GetLastError();
		мКлиент = Неопределено;
		ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Ошибка,,,
		"Ошибка получения сообщений. Сессия ИД "+мИДСессии+". Подробности: "+т
		+Символы.ПС+СтрокаПодключенияДляЖР);
		
		мКлиент = Неопределено;
		
		ВызватьИсключение т;
	КонецПопытки; 
	
	Возврат consumerId;
	
КонецФункции


//--------------------------------------------------------------------------------

// Основной алгоритм
//
// Параметры:
//	ИмяОчереди 	- строка - очередь, откуда читаем данные
//	Клиент - Неопределено (прод) / Обработка (тест) - только для тестирования! 
//		Сюда передается мок (встроенная или внешняя обработка (объекь), которая
//		имитируем методы Рэббита.
//		Тест будет использовать объект этой обработки, созданный из
//		подсистемы Доп обработок
//
Процедура ЗагрузитьДанныеИзОчереди(пИмяОчереди, Знач пКлиент = Неопределено) Экспорт

	мИДСессии = Строка(Новый УникальныйИдентификатор);
	ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Информация,,,"Сессия запущена.ИД "+мИДСессии);
	
	Попытка
	
	    ИмяОчереди = пИмяОчереди;
		
		Если пКлиент = Неопределено Тогда
			Выполнить("мКлиент = PinkRabbit.ПолучитьКлиента();");
			//мКлиент = PinkRabbit.ПолучитьКлиента();
		Иначе 
			мКлиент = пКлиент;
		КонецЕсли;
			
		мКоличествоПолученных = 0; 
		мСчетчикПересозданияКлиентаРэббит = 0;

		consumerId = Подключиться();

		
		// Будем пересодавать клиента, когда накопится 1000
		// Причина - клиент падает, возможно из-за утечек памяти в компоненте
		СчетчикПересозданияКлиентаРэббит = 0;
		НетСообщений = Ложь;
		
			
		//Пока 1 = 1 Цикл
					
		    Обработано = ВнутреннийЦикл();						
			
			мКлиент.BasicCancel("");                             
			
			мКлиент = Неопределено;
			
		//	Если Обработано > 0 Тогда
		//		
		//		Выполнить("мКлиент = PinkRabbit.ПолучитьКлиента();");
		//		
		//		consumerId = Подключиться();
		//		
		//	Иначе 
		//		
		//		Прервать;
		//		
		//	КонецЕсли;
		//	
		//КонецЦикла;
		
		//Если НЕ мКлиент = Неопределено Тогда
		//	мКлиент.BasicCancel("");
		//	
		//	мКлиент = Неопределено;
		//КонецЕсли;
		
		
		//мКлиент = Неопределено;
		
		ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Информация,,,"Получено сообщений "+строка(мКоличествоПолученных)+". Сессия ИД "+мИДСессии);
		ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Информация,,,"Сессия Завершена.ИД "+мИДСессии);
		
	
	Исключение
		
		Если мКлиент <> Неопределено Тогда
			т = мКлиент.GetLastError();
		Иначе 
			т = ОписаниеОшибки();
		КонецЕсли;
		
		Попытка
			мКлиент.BasicCancel(""); 
		Исключение
		    //Сообщить(НСтр("ru = '"+ОписаниеОшибки()+"'"), СтатусСообщения.Внимание);
		КонецПопытки;
		
		Если ЗначениеЗаполнено(т) Тогда
			мКлиент = Неопределено;
			текстОшибки = "Ошибка получения сообщений - ошибка RabbitMQ. Сессия ИД "+мИДСессии+". Подробности: "+т;
			ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Ошибка,,,текстОшибки);
			
			мЛоггер.ерр(текстОшибки);
		Иначе
			
			т = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			текстОшибки = "Ошибка получения сообщений - ошибка НЕ RabbitMQ. Сессия ИД "+мИДСессии+". Подробности: "+т;
			ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Ошибка,,,текстОшибки);
			
			мЛоггер.ерр(текстОшибки);
		КонецЕсли;
		
		мКлиент = Неопределено;
	КонецПопытки;

КонецПроцедуры


Функция ВнутреннийЦикл() Экспорт
 				
		
    //consumerId - Строка - [НЕ РЕАЛИЗОВАНО] Имя зарегистрированного потребителя
	//outdata - Строка - Выходной параметр. Тело сообщения.
	//messageTag - Число - Выходной параметр. Тег сообщения для подтверждения через метод BasicAck
	//timeout - Число - Таймаут ожидания сообщения в миллисекундах. 
	//Не рекомендуется ставить параметр слшком низким, т.к. сообщение просто может не успеть
	//прийти из очереди. Рекомендуемый диапазон 3000-60000.
	
	ПолучаемоеСообщение 	= "";
	мТегСообщения			= 0;
	
	Обработано = 0;
	
	Пока мКлиент.BasicConsumeMessage(consumerId, ПолучаемоеСообщение, мТегСообщения, 3000) Цикл
		
		Обработано = Обработано + 1; //Это должно быть до счетчика пересоздания!
		
		//мСчетчикПересозданияКлиентаРэббит = мСчетчикПересозданияКлиентаРэббит + 1;
		//
		//Если мСчетчикПересозданияКлиентаРэббит >= 1000 Тогда
		//	мСчетчикПересозданияКлиентаРэббит = 0;
		//	Прервать;
		//КонецЕсли;
		
		мКоличествоПолученных = мКоличествоПолученных + 1;
		
		мЛоггер.дебаг("tag: %1, json: %2", мТегСообщения, ПолучаемоеСообщение);
		
		NeedReject = false;
		Попытка
			мЧтениеJSON.УстановитьСтроку(ПолучаемоеСообщение);
			тДанные = ПрочитатьJSON(мЧтениеJSON,,,,"ФункцияВосстановленияJSON",ЭтотОбъект);//структура			
			ТипОбъекта = тДанные.type;
			текст = "Обработка сообщения с тэгом "+мТегСообщения+". Тип объекта = "+Строка(ТипОбъекта)+". Сессия ИД "+мИДСессии;
			ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Информация,,,текст);
			мЛоггер.инфо(текст);
		Исключение                                                                 
			т = ОписаниеОшибки();
			текст = "Удалено из очереди сообщение_ с тэгом "+мТегСообщения+". Ошибка чтения json: "+Строка(т)+". Сессия ИД "+мИДСессии;
			ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Ошибка,,,текст);
			мЛоггер.ерр(текст);
			NeedReject = true;
		КонецПопытки;
		
		ПолучаемоеСообщение = "";
		
		if NeedReject = true then
			DoReject();
			продолжить;
		endif;

		// найти плагин
		Плагин = Неопределено;
		Успешно = НайтиПлагин(ТипОбъекта, Плагин);
		Если НЕ Успешно Тогда
			т = "Для типа данных <"+Строка(ТипОбъекта)+"> нет доп. обработки импорта json из RabbitMQ!";
			
			// а если объектов будет миллион?
			ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Предупреждение, ,,	т);
			мЛоггер.варн(т);
			
			DoReject();
			Продолжить;
			
		КонецЕсли;
		
        NeedReject = false;
		//НачатьТранзакцию();
		
		Попытка
			Плагин.сетИдВызова(мИдВызова);
		Исключение
			текст="Плагин еще не подключен к подсистема Таск менеджер! Тип объекта: "+Строка(ТипОбъекта);
			ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Предупреждение,,,текст);
			мЛоггер.варн(текст);
		КонецПопытки;
		
		Попытка	
								
			Плагин.ЗагрузитьОбъект(тДанные); //здесь может быть исключение
			
			мКлиент.BasicAck(мТегСообщения); 			

			текст="Успешно загружено сообщение с тэгом <"+Строка(мТегСообщения)+">. Сессия ИД "+мИДСессии;
			ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Информация,,,текст);
			мЛоггер.инфо(текст);
			
			мТегСообщения = 0; // Обнуляем, чтобы избежать утечку памяти
			
			//ЗафиксироватьТранзакцию();
			
		Исключение
			//Если ТранзакцияАктивна() Тогда
			//	ОтменитьТранзакцию();
			//КонецЕсли;
							
			т = мКлиент.GetLastError();
			Если НЕ ЗначениеЗаполнено(т) Тогда
				// ошибка НЕ в компоненте
				т = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				текст="Ошибка обработки (Не в PinkRabbitMQ.dll) сообщения с тэгом <"+Строка(мТегСообщения)+">. Сессия ИД "+мИДСессии+". Подробности: "+т;
				ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Ошибка,,,текст);
				мЛоггер.ерр(текст);
			Иначе 
				текст = "Ошибка PinkRabbitMQ.dll при обработке сообщения с тэгом <"+Строка(мТегСообщения)+">. Сессия ИД "+мИДСессии+". Подробности: "+т;
				ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Ошибка,,,текст);
				мЛоггер.ерр(текст);
			КонецЕсли; 
			
			NeedReject = true;
			
		КонецПопытки; 
		
		if NeedReject = true then
			DoReject();			
		endIf;
		
		мТегСообщения = 0; // Обнуляем, чтобы избежать утечку памяти	
		
	КонецЦикла;

	мЛоггер.инфо("Завершение итерации: ВнутреннийЦикл(). Обработано сообщений = "+Строка(Обработано));
	Возврат Обработано;
	
КонецФункции


// Описание_метода
//
// Параметры:
//	Параметр1 	- Тип1 - 
//
Процедура DoReject()

	Попытка
		мКлиент.BasicReject(мТегСообщения);			
		мЛоггер.инфо("Выполнили BasicReject. Тэг = %1", мТегСообщения);
		мТегСообщения = 0;
	Исключение           
		мТегСообщения = 0;
		т = мКлиент.GetLastError();
		текст = "Ошибка RabbitMQ при пропуске (BasicReject без загрузки в 1С, т.к. не найден нужный плагин) сообщения."+
			" Сессия ИД "+мИДСессии+". Подробности: "+т;
		ЗаписьЖурналаРегистрации(ИмяСобытияЖР,УровеньЖурналаРегистрации.Ошибка,,,текст);
		мЛоггер.ерр(текст);
		ВызватьИсключение т;
	КонецПопытки;			
		
КонецПроцедуры








Функция ФункцияВосстановленияJSON(Свойство, Значение, ДопПараметры) Экспорт
	
	Если Свойство = "Date"Тогда
		Возврат ПрочитатьДатуJSON(Значение, ФорматДатыJSON.ISO);
	КонецЕсли;
	Если Свойство = "Период" Тогда
		Попытка
			Возврат ПрочитатьДатуJSON(Значение, ФорматДатыJSON.ISO);
		Исключение
			Возврат Значение;
		КонецПопытки;
	КонецЕсли;
	
КонецФункции



ИмяСобытияЖР = "Импорт_из_RabbitMQ_УТ";





