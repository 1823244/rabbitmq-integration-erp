// чек-лист по доработке для другого вида объекта

// 1 поменять содержимое макета "Макет"

Перем КэшОбъектовПлагинов; //рэббит
Перем Плагины;//рэббит

Перем КонтекстЯдра;
Перем Ожидаем;
Перем ИнтеграцияРэббит;

Перем ЭтоЗначениеЗаполняетсяПередЗапускомТеста;
Перем ЭтоЗначениеЗаполняетсяПослеЗапускаТеста;
Перем ТекстИсключенияПадающегоТеста;

Процедура Инициализация(КонтекстЯдраПараметр) Экспорт
	КонтекстЯдра = КонтекстЯдраПараметр;
	Ожидаем = КонтекстЯдра.Плагин("УтвержденияBDD");
	ИнтеграцияРэббит = КонтекстЯдра.Плагин("ИнтеграцияРэббит");
КонецПроцедуры

Процедура ЗаполнитьНаборТестов(НаборТестов) Экспорт
	
	НаборТестов.Добавить("ЗагрузитьНовыйДокумент");
	НаборТестов.Добавить("ОбновитьПроведенныйДокумент");
	НаборТестов.Добавить("ОбновитьНЕПроведенныйДокумент");
	//НаборТестов.Добавить("ТестДолжен_ПроверитьВызов_ПослеЗапускаТеста_УПадающегоТеста");
	//НаборТестов.Добавить("ТестДолжен_ПроверитьРезультатТеста_Когда_ПередЗапускаТеста_СОшибкой");
	//НаборТестов.Добавить("ТестДолжен_ПроверитьРезультатТеста_Когда_ПослеЗапускаТеста_СОшибкой");
	
КонецПроцедуры

Процедура ПередЗапускомТеста() Экспорт
	ЭтоЗначениеЗаполняетсяПередЗапускомТеста = Истина;
	ЭтоЗначениеЗаполняетсяПослеЗапускаТеста = Неопределено;
	
	НачатьТранзакцию();
КонецПроцедуры

Процедура ПослеЗапускаТеста() Экспорт
	ЭтоЗначениеЗаполняетсяПослеЗапускаТеста = Истина;
	
	ОтменитьТранзакцию();
КонецПроцедуры

Процедура ПередЗапускомТеста_СОшибкой() Экспорт
	ВызватьИсключение "ПередЗапускомТеста_СОшибкой";
КонецПроцедуры

Процедура ПослеЗапускаТеста_СОшибкой() Экспорт
	ВызватьИсключение "ПослеЗапускаТеста_СОшибкой";
КонецПроцедуры






// загрузить новый документ
Процедура ЗагрузитьНовыйДокумент() Экспорт
	
	
	Плагины();
	
	
	json = ЭтотОбъект.ПолучитьМакет("Макет").ПолучитьТекст();

	мЧтениеJSON = Новый ЧтениеJSON;
	мЧтениеJSON.УстановитьСтроку(json);
	тДанные = ПрочитатьJSON(мЧтениеJSON,,,,"ФункцияВосстановленияJSON",ЭтотОбъект);//структура
	
	//подменяем гуид
	тДанные.identification.Ref = Строка(Новый УникальныйИдентификатор);
	
    ТипОбъекта = тДанные.type;
	Плагин = Неопределено;
	Успешно = НайтиПлагин(ТипОбъекта, Плагин);
	Ожидаем.Что(
		Успешно, "Не найден плагин Импорта из Розницы для типа данных "+строка(ТипОбъекта))
			.Равно(Истина);
	
	Плагин.ЗагрузитьОбъект(тДанные); //здесь может быть исключение
	
	СозданныйДок = Документы.ЗаказНаПеремещение.ПолучитьСсылку(Новый УникальныйИдентификатор(тДанные.identification.Ref));
	
	Ожидаем.Что(
		СокрЛП(СозданныйДок.ВерсияДанных), "Документ найден по ГУИДу")
			.НЕ_().Равно("");
	
	
КонецПроцедуры

// обновить проведенный документ
Процедура ОбновитьПроведенныйДокумент() Экспорт
	
	
	Плагины();
	
	
	json = ЭтотОбъект.ПолучитьМакет("Макет").ПолучитьТекст();

	мЧтениеJSON = Новый ЧтениеJSON;
	мЧтениеJSON.УстановитьСтроку(json);
	тДанные = ПрочитатьJSON(мЧтениеJSON,,,,"ФункцияВосстановленияJSON",ЭтотОбъект);//структура
	
	//подменяем гуид
	гуид = Строка(Новый УникальныйИдентификатор);
	тДанные.identification.Ref = гуид;
	
    ТипОбъекта = тДанные.type;
	Плагин = Неопределено;
	Успешно = НайтиПлагин(ТипОбъекта, Плагин);
	Ожидаем.Что(
		Успешно, "Не найден плагин Импорта из Розницы для типа данных "+строка(ТипОбъекта))
			.Равно(Истина);
	
	Плагин.ЗагрузитьОбъект(тДанные); //здесь может быть исключение
	
	СозданныйДок = Документы.ЗаказНаПеремещение.ПолучитьСсылку(Новый УникальныйИдентификатор(гуид));
	
	Ожидаем.Что(
		СокрЛП(СозданныйДок.ВерсияДанных), "Документ не найден по ГУИДу")
			.НЕ_().Равно("");
			
	СтараяВерсия = СокрЛП(СозданныйДок.ВерсияДанных);

	СозданныйДок.ПолучитьОбъект().Записать(РежимЗаписиДокумента.Проведение);
	
	Плагин.ЗагрузитьОбъект(тДанные); //здесь может быть исключение	
	
	СозданныйДок = Документы.ЗаказНаПеремещение.ПолучитьСсылку(Новый УникальныйИдентификатор(гуид));

	СозданныйДок.ПолучитьОбъект().Записать(РежимЗаписиДокумента.Проведение);
	
	Ожидаем.Что(
		СокрЛП(СозданныйДок.ВерсияДанных), "Документ не обновлен. Версия данных не изменилась")
			.НЕ_().Равно(СтараяВерсия);
	
КонецПроцедуры

// обновить НЕ проведенный документ
Процедура ОбновитьНЕПроведенныйДокумент() Экспорт
	
	
	Плагины();
	
	
	json = ЭтотОбъект.ПолучитьМакет("Макет").ПолучитьТекст();

	мЧтениеJSON = Новый ЧтениеJSON;
	мЧтениеJSON.УстановитьСтроку(json);
	тДанные = ПрочитатьJSON(мЧтениеJSON,,,,"ФункцияВосстановленияJSON",ЭтотОбъект);//структура
	
	//подменяем гуид
	гуид = Строка(Новый УникальныйИдентификатор);
	тДанные.identification.Ref = гуид;
	
    ТипОбъекта = тДанные.type;
	Плагин = Неопределено;
	Успешно = НайтиПлагин(ТипОбъекта, Плагин);
	Ожидаем.Что(
		Успешно, "Не найден плагин Импорта из Розницы для типа данных "+строка(ТипОбъекта))
			.Равно(Истина);
	
	Плагин.ЗагрузитьОбъект(тДанные); //здесь может быть исключение
	
	СозданныйДок = Документы.ЗаказНаПеремещение.ПолучитьСсылку(Новый УникальныйИдентификатор(гуид));
	
	Ожидаем.Что(
		СокрЛП(СозданныйДок.ВерсияДанных), "Документ не найден по ГУИДу")
			.НЕ_().Равно("");
			
	СтараяВерсия = СокрЛП(СозданныйДок.ВерсияДанных);

	//СозданныйДок.ПолучитьОбъект().Записать(РежимЗаписиДокумента.Проведение);
	
	Плагин.ЗагрузитьОбъект(тДанные); //здесь может быть исключение	
	
	СозданныйДок = Документы.ЗаказНаПеремещение.ПолучитьСсылку(Новый УникальныйИдентификатор(гуид));

	//СозданныйДок.ПолучитьОбъект().Записать(РежимЗаписиДокумента.Проведение);
	
	Ожидаем.Что(
		СокрЛП(СозданныйДок.ВерсияДанных), "Документ не обновлен. Версия данных не изменилась")
			.НЕ_().Равно(СтараяВерсия);
	
КонецПроцедуры


Функция ФункцияВосстановленияJSON(Свойство, Значение, ДопПараметры) Экспорт
	
	Если Свойство = "Date"Тогда
		Возврат ПрочитатьДатуJSON(Значение, ФорматДатыJSON.ISO);
	КонецЕсли;
	Если Свойство = "Период"Тогда
		Возврат ПрочитатьДатуJSON(Значение, ФорматДатыJSON.ISO);
	КонецЕсли;
	//Если Свойство = "Сумма" Тогда
	//	Возврат XMLЗначение(Тип("Число"),Значение);
	//КонецЕсли;
	// в 1С:Розница нет спр. Валюты!
	//Если Свойство = "Валюта" Тогда
	//	Возврат Справочники.Валюты.НайтиПоКоду(Значение);
	//КонецЕсли;
	
КонецФункции

#Область Плагины

// Собирает плагины из спр Доп. обработки в ТЗ
//
// Параметры:
//	Параметр1 	- Тип1 - 
//
// Возвращаемое значение:
//	Тип: Тип_значения
//
Функция НайтиПлагиныВДопОбработках()
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	спр.Ссылка КАК Ссылка,
		|	спр.ИмяОбъекта КАК ИмяОбъекта
		|ИЗ
		|	Справочник.ДополнительныеОтчетыИОбработки КАК спр
		|ГДЕ
		|	спр.ИмяОбъекта ПОДОБНО ""Плагин_RabbitMQ_импорт_из_Розницы%""  И спр.ПометкаУдаления = ЛОЖЬ
		|	И НЕ спр.Публикация = &ПубликацияОтключена";
		
		
	Запрос.УстановитьПараметр("ПубликацияОтключена", Перечисления.ВариантыПубликацииДополнительныхОтчетовИОбработок.Отключена);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Возврат РезультатЗапроса.Выгрузить();
	
КонецФункции

// Подключает плагины - обработки, формирующие json-тексты из объектов базы данных
//
// Параметры:
//	Параметр1 	- Тип1 - 
//
Процедура Плагины() Экспорт
	
	Если ТипЗнч(Плагины) <> Тип("Структура") Тогда
		Плагины = Новый Структура;
	Иначе 
		Плагины.Очистить();
	КонецЕсли;
	
	
	// универсальный код подключения плагина
	
	ТЗ = НайтиПлагиныВДопОбработках();
	Для каждого стрк Из ТЗ Цикл

		ИмяОбработки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(стрк.ИмяОбъекта, ".");//разделим на имя расширени
		
		массивСлов = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяОбработки[0], "_");
		
		//Плагин_RabbitMQ_импорт_из_ЕРП_Справочник_Номенклатура.epf	
		//ключ - тип объекта МД (напр. Справочник_Номенклатура), значение - ссылка в Доп обработках
		Ключ = массивСлов[5] + "_" + массивСлов[6];

		Плагины.Вставить(Ключ, стрк.Ссылка);
		
	КонецЦикла;	
	
	
	// теперь создание объектов обработок
	
	КэшОбъектовПлагинов = Новый ТаблицаЗначений;
	КэшОбъектовПлагинов.Колонки.Добавить("ТипОбъекта");//строка в формате "Справочник_Номенклатура"
	КэшОбъектовПлагинов.Колонки.Добавить("ПлагинСсылка");//спр ссылка Доп. обработки
	КэшОбъектовПлагинов.Колонки.Добавить("ОбъектПлагина");//объект обработки
	//индексы
	КэшОбъектовПлагинов.Индексы.Добавить("ТипОбъекта");
	КэшОбъектовПлагинов.Индексы.Добавить("ПлагинСсылка");
	
	Для каждого стрк Из Плагины Цикл
		НовСтр = КэшОбъектовПлагинов.Добавить();
		НовСтр.ТипОбъекта 		= стрк.Ключ;
		НовСтр.ПлагинСсылка 	= стрк.Значение;
		НовСтр.ОбъектПлагина 	= ДополнительныеОтчетыИОбработки.ОбъектВнешнейОбработки(стрк.Значение);
	КонецЦикла;
	
		
КонецПроцедуры

// Ищет плагин для указанного типа объекта в кэше - ТЗ "КэшОбъектовПлагинов"
// Параметры:
//	ТипОбъекта 	- строка - это не ТипЗнч()! а вот так: Объект.Метаданные().ПолноеИмя();
//	Плагин - объект обработки - возвращаемый параметр
//
// Возвращаемое значение:
//	Тип: Булево. Истина в случае успеха
//
Функция НайтиПлагин(Знач ТипОбъекта, Плагин = Неопределено)
	
	ТипОбъекта = СтрЗаменить(ТипОбъекта, ".", "_");
	
	Рез = КэшОбъектовПлагинов.Найти(ТипОбъекта, "ТипОбъекта");
	Если НЕ Рез = Неопределено Тогда
		Плагин = Рез.ОбъектПлагина;
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
	
КонецФункции


#КонецОбласти 	

